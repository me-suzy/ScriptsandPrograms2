<?  ##############################################
   ### MySource ------------------------------###
  ##- Notitia   Module -------- PHP4 ---------##
 #-- Copyright Squiz.net ---------------------#
##############################################
## $Source: /home/cvsroot/xtras/web/extensions/notitia/xtras/attribute/types/selection/selection.inc,v $
## $Revision: 1.38 $
## $Author: achadszinow $
## $Date: 2004/02/19 03:18:06 $
#######################################################################

#---------------------------------------------------------------------#


class Web_Extension_Notitia_Attribute_Type_Selection extends Web_Extension_Notitia_Attribute_Type {

	 ################################################################
	# This is a static thingy that stores special information about
	# a particular type.
	var $settings = array(
			'preferred_alignment' => 'left',
			'generates_varieties' => true,
			'variable'            => true,
			'variation_types'     => array(
				'replace'         => 'Replace',
				'merge_onto'      => 'Merge Onto (multiple only)',
				'merge_under'     => 'Merge Under (multiple only)',
			),
			'value_formats' => array(
				'raw' => 'Raw Encoded String',
				'array' => 'Key -> Label Array',
				'keys' => 'String of Keys',
				'labels' => 'String of Labels',
				'keys_space' => 'String of Keys Seperated by Spaces',
				'labels_space' => 'String of Labels Seperated by Spaces',
				'keys_nl' => 'String of Keys Seperated by a newline',
				'labels_nl' => 'String of Labels Seperated by a newline',
				'keys_br' => 'String of Keys Seperated by a HTML break',
				'labels_br' => 'String of Labels Seperated by HTML break',
				'keys_tab' => 'Ordered table of Keys',
				'labels_tab' => 'Ordered table of Labels'
			),
			'search_formats' => array (
				'exact' => 'Exact Match All Options',
				'subset'  => 'Subset or Exact Match',
				'intersect' => 'Intersect (Some options the same)'
			),
			'edit_formats' => array (
				'raw' => 'Standard'
			),
			'sort_formats' => array (
				'raw' => 'Alphabetically by Key',
				'raw<' => 'Reverse Alphabetically by Key'
			),
			'rule_types' => array (
				'must_answer' => 'Must be answered',
			),
			'requires_context_values' => false,
			'sub_type_name' => 'selection',
			'table_settings' => array(
				'sub_table_name' => ''
			)
	);

	 #############################################
	# Convert a string array to a string and back
	function ar2str($array) {
		$options = $this->get_options();
		return implode('|',array_intersect(array_keys($options),$array));
	}

	function str2ar($string) {
		return array_intersect(array_keys($this->get_value('options')),explode('|',$string));
	}

	 ##################################################
	# Takes an original values, and variation and a 
	# variation type, and returns the varied result
	function vary_value($type, &$new_value, &$original) {
		switch($type) {
			case 'merge_onto':
				return $this->ar2str(array_merge($this->str2ar($new_value),$this->str2ar($original)));
				break;
			case 'merge_under':
				return $this->ar2str(array_merge($this->str2ar($original),$this->str2ar($new_value)));
				break;
			case 'replace':
				return $new_value;
			default:
				return $original;
				break;
		}
	}
	
	
	 ######################################################################
	# Returns the number of possible varieties generated by this attribute
	function get_variety_count(&$value) {
		return count($this->str2ar($value));
	}

	 ############################################
	# Returns the list of variety names
	function &get_variety_names(&$value) {
		$labels = $this->get_options();
		foreach($this->str2ar($value) as $key) {
			$r[] = $labels[$key];
		}
		$tmp = array(0=>"");
		if(!is_array($r) || !count($r)) return $tmp;
		return $r;
	}
	
	 #############################################################
	#  Returns the value formatted in a nice way for printing
	function formatted_value(&$value, $format = 'labels_space') {
		$r = '';
		$options = $this->get_options();
		if(!$format) $format = 'labels_space';
		switch($format) {
			case 'array':
				foreach($this->str2ar($value) as $key) $r[$key] = $options[$key];
				return $r;
			case 'keys':
				return implode('',$this->str2ar($value));
			case 'labels':
				foreach($this->str2ar($value) as $key) $r .= $options[$key];
				return $r;
			case 'keys_space':
				return implode(' ',$this->str2ar($value));
			case 'labels_space':
				foreach($this->str2ar($value) as $key) $r .= ' '.$options[$key];
				return ltrim($r);
			case 'keys_nl':
				return implode("\n",$this->str2ar($value));
			case 'labels_nl':
				foreach($this->str2ar($value) as $key) $r .= "\n".$options[$key];
				return ltrim($r);
			case 'keys_br':
				return implode('<br>',$this->str2ar($value));
			case 'labels_br':
				$label_array = array();
				foreach($this->str2ar($value) as $key) {
					$label_array[] = $options[$key];
				}
				return implode('<br />',$label_array);
			case 'labels_tab':
				$label_table=true;
				# Continue into keys_tab
			case 'keys_tab':
				$html = '<table><tr>';
				$value_array = $this->str2ar($value);
				foreach ($options as $key=>$label) {
					$html .= '<td '.($this->parameters['order_table_width']?'width="'.$this->parameters['order_table_width'].'px"':'').'>';
					if($label_table && in_array($label,$value_array)) $html .= $label;
					elseif (!$label_table && in_array($key,$value_array)) $html .= $key;
					else $html .'&nbsp;';
					$html .= '</td>';
				}
				$html .= '</tr></table>';
				return $html;
			case 'raw': default:
				return $value;
		}
	}

	 #############################################
	# Prints the interface for filling in a value
	function print_concise_field($prefix,&$value) {
		$options = $this->get_options();
		if($this->get_value('multiple')) $value = $this->str2ar($value);
		if($this->get_value('style') == 'list') {
			if ($this->get_value('multiple')) {
				echo multiple_combo_box($prefix.'value', $options, $value, ($this->get_value('width')?'style="width:'.$this->get_value('width').'px"':''),$this->get_value('maxlength'), $this->get_value('height'));
			} else {
				echo combo_box($prefix.'value',$options, $value, ($this->get_value('width')?'style="width:'.$this->get_value('width').'px"':''),$this->get_value('maxlength') ,$this->get_value('height'));
			}
		} else {
			echo '<table cellpadding="0" cellspacing="0" border="0"><tr>';
			reset($options);
			$i = 0;
			while(list($key,$val) = each($options)) {
				if($this->get_value('multiple')) {
					echo ("<td>&nbsp;<input type=checkbox name=\"$prefix"."value[$i]\" value=\"$key\" ".((in_array($key,$value))?" checked":"")."> $val</td>");
				} else {
					echo ("<td>&nbsp;<input type=radio name=\"$prefix"."value\" value=\"$key\" ".(($key == $value)?" checked":"")."> $val</td>");
				}
				if ((($i++) % $this->get_value('columns')) == ($this->get_value('columns') - 1)) {
					echo("</tr><tr>");
				}
			}
			echo '</tr></table>';
		}
	}


	 #############################################
	# Prints the interface for filling in a value
	function print_field($prefix,&$value) {
		$this->print_concise_field($prefix,$value);
		if($note = &$this->get_value('note')) {
			echo '<span class="smallprint"><br />'.$note.'</span>';
		}
	}

	/**
	* Processes changes to an attribute
	*
	* @param  string  $prefix                 The attribute changing prefix
	* @param  &string $value_destination      The current value
	* @param  string  $format                 Don't remember
	* @param  &string &$rules_broken_messages Var to hold broken rull messages
	* @access public
	* @return string
	*/
	function process_field($prefix, &$value_destination, $format, &$rules_broken_messages) {
		$input = $_REQUEST[$prefix.'value'];
		$input = gpc_stripslashes($input);
		if(is_array($input)) {
			$input = $this->ar2str($input);
		}
		$this->validate_value($input, $rules_broken_messages);
		if((string) $value_destination == (string) $input) {
			return;
		}

		if ($rules_broken_messages) {
			return 'Rule broken in attribute '.$this->attribute->name.'. '.$rules_broken_messages;
		} else {
			$value_destination = $input;
			return $this->attribute->name.' updated.';
		}
	}

	/**
	* Prints the option definition interface
	*
	* @access public
	* @return void
	*/
	function print_option_definition_field() {
		$options = $this->get_options();
		$sort_option_box = combo_box('resort_options', array('' => 'Keep Current Order', 'ka' => 'Keys (Alphabetically)', 'kra' => 'Keys (Reverse Alphabetically)', 'la' => 'Labels (Alphabetically)', 'lra' => 'Labels (Reverse Alphabetically)'), '');
		echo '<table cellspacing="0" cellpadding="1" border="0">';
		echo '<tr><td><b>Resort Options by:</b></td><td>'.$sort_option_box.'</td><tr>';
		echo '<tr><td>&nbsp;</td></tr>';
		echo '<tr><td><b>Key</b></td><td><b>Label</b></td></tr>';
		reset($options);
		$i = 0;
		while($i < count($options) + 4) {
			list($key,$label) = each($options);
			echo '<tr><td>';
			echo text_box("selection_options_keys[$i]", $key, 20, 50);
			echo '</td><td>';
			echo text_box("selection_options_labels[$i]", $label, 50, 1000);
			echo '</td></tr>';
			$i++;
		}
		echo '</table>' ;
		echo '<span class="smallprint">Please keep keys short and unique. Keys are unique identifiers of the options. Labels may be longer and descriptive. Some characters are not allowed and will be removed.</span>';
	}

	/**
	* Processes the option definition interface
	*
	* @access public
	* @return string
	*/
	function process_option_definition_field() {
		$options = &$this->get_options();

		# First lets sort out the options changes
		$selection_options_keys = $_POST['selection_options_keys'];
		$selection_options_labels = $_POST['selection_options_labels'];
		$new_options = array();
		foreach($selection_options_keys as $i => $key) {
			$label = $selection_options_labels[$i];
			$key = str_replace('|','',$key);
			if($key == '') continue;
			$new_options[$key] = $label;
		}
		$options = $new_options;

		# Now lets handle any sorting changes
		$resort_code = $_POST['resort_options'];
		switch($resort_code) {
			case 'ka':
				ksort($options);
				break;
			case 'kra':
				krsort($options);
				break;
			case 'la':
				asort($options);
				break;
			case 'lra':
				arsort($options);
				break;
			default:
				break;
		}
		return 'Options updated.';
	}

	/**
	* Checks the value is valid
	*
	* @param  string &$value            The value we need to check against the rules
	* @param  string &$rule_broken_msgs The broken rule messages
	* @access public
	* @return void
	*/
	function validate_value(&$value, &$rule_broken_msgs) {
		# Check for rules so we need the rules array
		$this->validate_value_rules($value, $rule_broken_msgs);
		# Do normal checks
		$value_array = explode('|',$value);
		$value = array();
		$options = $this->get_options();
		$option_keys = array_keys($options);
		$value_added = false;
		foreach($value_array as $v) {
			if(in_array($v, $option_keys)) {
				$value[] = $v;
			}
		}
		# If they are saving and we haven't got any valid values we will return the default cause validate can't return an invalid option like blank cause that ain't valid!
		if (empty($value)) {
			$def = $this->attribute->get_default_value($this->attribute->categoryid);
			$value[] = $this->attribute->get_default_value($this->attribute->categoryid);
		}
		$value = $this->ar2str($value);
	}

	 ###################################################
	# Returns a query object which can be given back to
	# print_search_field() or get_search_sql_clause()
	function &process_search_field($prefix,$format,$not_null) {
		$input = $_REQUEST[$prefix.'qvalue'];
		$q = gpc_stripslashes($input);
		if(is_array($q)) return $this->ar2str($q);
		return $q;
	}

	 ##############################################
	# Returns an SQL WHERE subclause for searching
	function get_search_sql_clause($query,$format,$value_string='v.value') {
		switch($format) {
			case 'exact': case 'match': case '_match':
				$cmp = 'STRCMP('.$value_string.',"'.addslashes($query).'")=0';
				break;
			case 'subset': case 'intersect': case 'partial': case '_partial':
				$cmp = '0='.(($format=='intersect')?'1':'0');
				foreach(explode('|',$query) as $e) {
					$cmp .= (($format=='intersect')?' OR':' AND').' CONCAT(\'|\','.$value_string.',\'|\') LIKE "%|'.$e.'|%"';
				}
				break;
		}
		return $cmp;
	}


	 ##############################################
	# Returns an SQL expression that evalutates a clause
	function get_search_sql_score($query,$format,$value_string='v.value') {
		switch($format) {
			case 'exact':
				return 1;
			case 'subset': case 'intersect':
				$cmp = '0';
				foreach(explode('|',$query) as $e) {
					$cmp .= '+ CONCAT(\'|\','.$value_string.',\'|\') LIKE "%|'.$e.'|%" / '.count($query);
				}
				return $cmp;
		}
	}

	/**
	* Prints the form for uploading the csv file.
	* 
	* @returns void
	* @access public
	*/
	function print_file_upload_form() {
		$session = &get_mysource_session();
		$e = &$this->get_notitia_system();
		echo file_upload('csv_option_file', "$e->data_path", 50000000, "$this->codename"."_import.{$session->user->id}.tmp",array('csv','txt'));
		echo '<br /><span class=smallprint>When importing you must delimit your file with comma\'s and the must only be two columns. The first column is key and the second column is label</span>';
	}

	/**
	* Processes the form for uploading the csv file and starts the whole import process.
	* 
	* @returns void
	* @access private
	*/
	function process_file_upload_form() {
		$options = &$this->get_options();
		$msgs = '';
		$session = &get_mysource_session();
		$e = &$this->get_notitia_system();
		commit_file_upload('csv_option_file', 1, 0, '', $e->data_path, "$this->codename"."_import.{$session->user->id}.tmp");
		if(file_exists($file = "$e->data_path/$this->codename"."_import.{$session->user->id}.tmp")) {
			global $SQUIZLIB_PATH;
			include_once("$SQUIZLIB_PATH/csv/csv.inc");
			$csv = new Csv($file);
			$csv->set_deliminator(',');
			$csv->import();
			$tmp = $csv->values;
			# delete it
			unlink($file);
			if (!empty($tmp)) {
				foreach($tmp as $values) {
					$key = $values[0];
					$label = $values[1];
					$key = ereg_replace("[\|]+","",$key);
					if(!$key) continue;
					$options[$key] = $label;
					$msgs .= 'Option '.$label.' added<br />';
				}
				return $msgs;
			}
		}
	}
	
	 ###########################
	# Prints out a search field
	function print_search_field($prefix,&$default,$format,$not_null) {
		if (isset($this->parameters['s_style']) && isset($this->parameters['s_width']) && isset($this->parameters['s_height']) && isset($this->parameters['s_columns']) && isset($this->parameters['s_multiple'])) {
			$n_style = $this->parameters['style'];
			$n_width = $this->parameters['width'];
			$n_height = $this->parameters['height'];
			$n_columns = $this->parameters['columns'];
			$n_multiple = $this->parameters['multiple'];
			$n_maxlength = $this->parameters['maxlength'];
			$this->parameters['style'] = $this->parameters['s_style'];
			$this->parameters['width'] = $this->parameters['s_width'];
			$this->parameters['height'] = $this->parameters['s_height'];
			$this->parameters['columns'] = $this->parameters['s_columns'];
			$this->parameters['multiple'] = $this->parameters['s_multiple'];
			$this->parameters['maxlength'] = $this->parameters['s_maxlength'];
		}
		$options = &$this->get_options();
		$non_searchable_options = $this->get_value('non_searchables');
		$save_options = $options;
		if (!empty($non_searchable_options)) {
			foreach($non_searchable_options as $options_key) {
				unset($options[$options_key]);
			}
		}

		switch($format) {
			case 'exact': case 'subset':
				if(!$this->parameters['multiple'] && !$not_null) {
					if ($this->get_value('s_blank_label') != null) {
						$blank = array('' => $this->get_value('s_blank_label'));
					} else {
						$blank = array('' => $this->get_value('s_blank_label'));
					}

					$options = array_merge($blank, $options);
				}
				$this->print_concise_field($prefix.'q',$default);
				break;

			case 'intersect':
				$tmp = $this->parameters['multiple'];
				$this->parameters['multiple'] = 1;
				$this->print_concise_field($prefix.'q',$default);
				$this->parameters['multiple'] = $tmp;
				break;
		}

		$options = $save_options;
		if (isset($this->parameters['s_style']) && isset($this->parameters['s_width']) && isset($this->parameters['s_height']) && isset($this->parameters['s_columns']) && isset($this->parameters['s_multiple'])) {
			$this->parameters['multiple'] = $n_multiple;
			$this->parameters['style'] = $n_style;
			$this->parameters['width'] = $n_width;
			$this->parameters['height'] = $n_height;
			$this->parameters['columns'] = $n_columns;
			$this->parameters['maxlength'] = $n_maxlength;
		}
	}

	/**
	* Sets in the request vars a static search
	*
	* @param   string $prefix Prefix
	* @param   string $value  A value
	* @param   string $format A search format
	* @access  public
	* @returns void
	*/
	function set_search_request($prefix,&$default,$format) {
		if (isset($this->parameters['s_style']) && isset($this->parameters['s_width']) && isset($this->parameters['s_height']) && isset($this->parameters['s_columns']) && isset($this->parameters['s_multiple'])) {
			$n_style = $this->parameters['style'];
			$n_width = $this->parameters['width'];
			$n_height = $this->parameters['height'];
			$n_columns = $this->parameters['columns'];
			$n_multiple = $this->parameters['multiple'];
			$this->parameters['style'] = $this->parameters['s_style'];
			$this->parameters['width'] = $this->parameters['s_width'];
			$this->parameters['height'] = $this->parameters['s_height'];
			$this->parameters['columns'] = $this->parameters['s_columns'];
			$this->parameters['multiple'] = $this->parameters['s_multiple'];
		}

		switch($format) {
			case 'exact': case 'subset':
				$this->set_concise_field($prefix.'q',$default);
				break;

			case 'intersect':
				$tmp = $this->parameters['multiple'];
				$this->parameters['multiple'] = 1;
				$this->set_concise_field($prefix.'q',$default);
				$this->parameters['multiple'] = $tmp;
				break;
		}

		if (isset($this->parameters['s_style']) && isset($this->parameters['s_width']) && isset($this->parameters['s_height']) && isset($this->parameters['s_columns']) && isset($this->parameters['s_multiple'])) {
			$this->parameters['multiple'] = $n_multiple;
			$this->parameters['style'] = $n_style;
			$this->parameters['width'] = $n_width;
			$this->parameters['height'] = $n_height;
			$this->parameters['columns'] = $n_columns;
		}
	}

	/**
	* Sets in the request vars a concise field
	*
	* @param   string $prefix Prefix
	* @param   string $value  A value
	* @access  public
	* @returns void
	*/
	function set_concise_field($prefix,$value) {
		if($this->get_value('multiple')) $value = $this->str2ar($value);
		if($this->get_value('style') == 'list') {
			$_REQUEST[$prefix.'value'] = $value;
		} else {
			$options = &$this->get_options();
			reset($options);
			$i = 0;
			while(list($key,$val) = each($options)) {
				if($this->get_value('multiple')) {
					if (in_array($key,$value)) {
						$_REQUEST[$prefix.'value['.$i.']'] = $key;
					}
				} else {
					if ($key == $value) {
						$_REQUEST[$prefix.'value'] = $key;
					}
				}
				$i++;
			}
		}
	}

	/**
	* Gets all the options for this selection attribute
	*
	* @access  public
	* @returns &array
	*/
	function &get_options() {
		return $this->get_value('options');
	}
}
?>
