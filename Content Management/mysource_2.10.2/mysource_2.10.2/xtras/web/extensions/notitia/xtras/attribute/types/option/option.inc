<?  ##############################################
   ### MySource ------------------------------###
  ##- Notitia   Module -------- PHP4 ---------##
 #-- Copyright Squiz.net ---------------------#
##############################################
## $Source: /home/cvsroot/xtras/web/extensions/notitia/xtras/attribute/types/option/option.inc,v $
## $Revision: 1.11 $
## $Author: nduggal $
## $Date: 2004/01/16 06:25:35 $
#######################################################################

#---------------------------------------------------------------------#

 ####################
# For numeric fields
class Web_Extension_Notitia_Attribute_Type_Option extends Web_Extension_Notitia_Attribute_Type {
	

	 ################################################################
	# This is a static thingy that stores special information about
	# a particular type.
	var $settings = array(
			'preferred_alignment' => 'left',
			'generates_varieties' => true,
			'variable'            => false,
			'variation_types'     => array(
				'replace'         => 'Replace',
				'merge_onto'      => 'Merge Onto',
				'merge_under'     => 'Merge Under',
			),
			'value_formats' => array(
				'raw' => 'Raw Array',
				'formatted' => 'List'
			),
			'search_formats' => array (
				# TO DO !!
				#'match'  => 'Complete Match One Option',
				#'partial'  => 'Partial Match One Option',
				#'complex' => 'Complex Match One Option'
			),
			'edit_formats' => array (
				'raw' => 'Standard'
			),
			'sort_formats' => array (
				'raw' => 'Alphabetically',
				'raw<' => 'Reverse Alphabetically'
			),
			'rule_types' => array (
				'must_answer' => 'Must be answered',
			),
			'requires_context_values' => false,
			'sub_type_name' => 'option',
			'table_settings' => array(
				'sub_table_name' => ''
			)
	);


	 ##################################################
	# Takes an original values, and variation and a 
	# variation type, and returns the varied result
	function vary_value($type, &$new_value, &$original) {
		switch($type) {
			case 'merge_onto':
				$r = array();
				foreach($new_value[option_names] as $k => $v) $r[option_names][$k] = $v;
				foreach($original[option_names] as $k => $v) $r[option_names][$k] = $v;
				return $r;
				break;
			case 'merge_under':
				$r = array();
				foreach($original[option_names] as $k => $v) $r[option_names][$k] = $v;
				foreach($new_value[option_names] as $k => $v) $r[option_names][$k] = $v;
				return $r;
				break;
			case 'replace':
				return $new_value;
			default:
				return $original;
				break;
		}
	}
	
	
	 ######################################################################
	# Returns the number of possible varieties generated by this attribute
	function get_variety_count(&$value) {
		if(!is_array($value)) return 0;
		return count($value[option_names]);
	}

	 ############################################
	# Returns the list of variety names
	function &get_variety_names(&$value) {
		$tmp = array(0=>"");
		if(!is_array($value)) return $tmp;
		$r = &$value[option_names];
		if(!is_array($r) || !count($r)) return $tmp;
		return $r;
	}

	 #############################################################
	# Makes a string out of a value, for storing in the database
	function serialize(&$v) {
		return serialize($v);
	}
	function unserialize(&$v) {
		$v = unserialize($v);
	}
	
	 #############################################################
	#  Returns the value formatted in a nice way for printing
	function formatted_value(&$value, $format = 'formatted') {
		if(!$format) $format = 'formatted';
		switch($format) {
			case 'formatted':
				foreach($value[option_names] as $id => $name) {
					$desc = &$value[option_descs][$id];
					$v .= "<li>$name".(($desc)?"<span class=smallprint><br>$desc</span>":"")."</li>";
				}
				return "<ul>$v</ul>";
			case 'raw': default:
				return $value;
		}
	}
	

	 #############################################
	# Prints an interface for defining the names of
	# the various options available
	function print_option_definition_field($prefix,&$value) {
		$options = &$value[option_names];
		$descriptions = &$value[option_descs];
		$default = &$value["default"];
		echo("<table cellpadding=2 cellspacing=0 border=0>");
		$i = 0;
		$existing_count = 0;
		$extras = 0;
		while($i++ >= 0) {
			if(isset($options[$i]) && strlen($options[$i]) > 0) {
				$existing = 1;
				$existing_count++;
				$name = &$options[$i];
				$desc = &$descriptions[$i];
			} else {
				unset($options[$i]);
				$existing = 0;
				$extras++;
				$name = "";
				$desc = "";
			}
			if($existing_count >= count($options) && $extras > 3) break;
			echo("<tr><td><b>$i.</b></td><td colspan=2>".text_box($prefix."value[option_names][$i]",$name,$this->get_value('width'),$this->get_value('maxlength')).(($existing)?"<input type=radio name=\"$prefix"."value[default]\" value=\"$i\" ".(($default==$i)?"checked":"").">":"")."</td></tr>");
			if($existing && $this->get_value('store_notes')) {
				echo("<tr><td></td><td valign=top>Desc:</td><td valign=top>".text_area($prefix."value[option_descs][$i]",$desc,$this->get_value('width'),3,255)."</td></tr>");
			}
		}
		echo("</table>");
	}


	 ##########################
	# Prints the default field
	function print_default_field() {
		$default = &$this->get_value("default");
		return $this->print_option_definition_field("default_",$default);
	}
	
	
	 #############################################
	# Prints the interface for filling in a value
	function print_concise_field($prefix,&$value) {
		return $this->print_option_definition_field($prefix,$value);
	}


	 #############################################
	# Prints the interface for filling in a value
	function print_field($prefix,&$value) {
		$this->print_concise_field($prefix,$value);
		if($note = &$this->get_value("note")) {
			echo("<span class=smallprint><br>$note</span>");
		}
	}

	/**
	* Processes changes to an attribute
	*
	* @param  string  $prefix                 The attribute changing prefix
	* @param  &string $value_destination      The current value
	* @param  string  $format                 Don't remember
	* @param  &string &$rules_broken_messages Var to hold broken rull messages
	* @access public
	* @return string
	*/
	function process_field($prefix, &$value_destination, $format, &$rules_broken_messages) {
		$input = $_REQUEST[$prefix.'value'];
		$input = gpc_stripslashes($input);
		$this->validate_value($input);
		$this->validate_value($input, $rules_broken_messages);
		if(equal_arrays($value_destination, $input)) return;

		if ($rules_broken_messages) {
			return 'Rule broken in attribute '.$this->attribute->name.'. '.$rules_broken_messages;
		} else {
			$value_destination = $input;
			return $this->attribute->name.' updated.';
		}
	}

	/**
	* Checks the value is valid
	*
	* @param  string &$value            The value we need to check against the rules
	* @param  string &$rule_broken_msgs The broken rule messages
	* @access public
	* @return void
	*/
	function validate_value(&$value, &$rule_broken_msgs) {
		#check for rules so we need the rules array
		$this->validate_value_rules($value, $rule_broken_msgs);

		# do normal checks
		$ids = array(); # Valid option ids
		if(!is_array($value)) $value = array("option_names"=>array());
		for(reset($value[option_names]); NULL !== ($id = key($value[option_names])); next($value[option_names])) {
			$value[option_names][$id] = trim($value[option_names][$id]);
			if(strlen($value[option_names][$id]) > 0) $ids[] = $id;
		}
		foreach($value[option_names] as $id => $name) {
			if(!in_array($id,$ids)) unset($value[option_names][$id]);
		}
		foreach($value[option_descs] as $id => $desc) {
			if(!in_array($id,$ids)) unset($value[option_descs][$id]);
		}
	}
}
?>