<?  ##############################################
   ### MySource ------------------------------###
  ##- Notitia   Module -------- PHP4 ---------##
 #-- Copyright Squiz.net ---------------------#
##############################################
## $Source: /home/cvsroot/xtras/web/extensions/notitia/xtras/attribute/types/category_list/category_list.inc,v $
## $Revision: 1.22 $
## $Author: brobertson $
## $Date: 2004/02/06 11:58:50 $
#######################################################################

#---------------------------------------------------------------------#


class Web_Extension_Notitia_Attribute_Type_Category_List extends Web_Extension_Notitia_Attribute_Type {

	 ################################################################
	# This is a static thingy that stores special information about
	# a particular type.
	var $settings = array(
			'preferred_alignment' => 'left',
			'generates_varieties' => false,
			'variable'            => true,
			'variation_types'     => array(
				'replace'         => 'Replace',
				'merge_onto'      => 'Merge Onto (multiple only)',
				'merge_under'     => 'Merge Under (multiple only)',
			),
			'value_formats' => array(
				'raw' => 'Raw Encoded String',
				'array' => 'Key -> Label Array',
				'keys' => 'String of Keys',
				'labels' => 'String of Labels',
				'keys_space' => 'String of Keys Seperated by Spaces',
				'labels_space' => 'String of Labels Seperated by a Space',
				'keys_nl' => 'String of Keys Seperated by a Newline',
				'labels_nl' => 'String of Labels Seperated by a Newline',
				'keys_br' => 'String of Keys Seperated by a HTML break',
				'labels_br' => 'String of Labels Seperated by HTML break',
				'category_linage' => 'String of Category lineages',
				'category_linage_space' => 'String of Category lineages seperated by a Spaces',
				'category_linage_nl' => 'String of Category lineages Seperated by a Newline',
				'category_linage_br' => 'String of Category lineages Seperated by a HTML break',
			),
			'search_formats' => array (
				'exact' => 'Exact Match All Options',
				'subset'  => 'Subset or Exact Match',
				'exactsubcat' => 'Exact Match including Subcategories',
				'subsetsubcat' => 'Subset Match including Subcategories',
				'intersect' => 'Intersect (Some options the same)'
			),
			'edit_formats' => array (
				'raw' => 'Standard'
			),
			'sort_formats' => array (
				'raw' => 'Alphabetically by Key',
				'raw<' => 'Reverse Alphabetically by Key'
			),
			'rule_types' => array (
				'must_answer' => 'Must Answer',
				'exclude_cats' => 'Categories Unselectable'
			),
			'requires_context_values' => false,
			'sub_type_name' => 'category_list',
			'table_settings' => array(
				'sub_table_name' => ''
			)
	);


	 #############################################
	# Convert a string array to a string and back
	function ar2str($array) {
		$root_categoryid = $this->get_value('root_categoryid');
		$category_list = $this->get_root_category_list($root_categoryid);
		return implode('|',array_intersect(array_keys($category_list), $array));
	}

	function str2ar($string) {
		$root_categoryid = $this->get_value('root_categoryid');
		$category_list = $this->get_root_category_list($root_categoryid);
		return array_intersect(array_keys($category_list), explode('|',$string));
	}

	 ##################################################
	# Takes an original values, and variation and a
	# variation type, and returns the varied result
	function vary_value($type, &$new_value, &$original) {
		switch($type) {
			case 'merge_onto':
				return $this->ar2str(array_merge($this->str2ar($new_value),$this->str2ar($original)));
				break;
			case 'merge_under':
				return $this->ar2str(array_merge($this->str2ar($original),$this->str2ar($new_value)));
				break;
			case 'replace':
				return $new_value;
			default:
				return $original;
				break;
		}
	}

	 ######################################################################
	# Returns the number of possible varieties generated by this attribute
	function get_variety_count(&$value) {
		return count($this->str2ar($value));
	}

	 #############################################################
	#  Returns the value formatted in a nice way for printing
	function formatted_value(&$value, $format = 'labels_space') {
		$r = '';
		switch($format) {
			case 'array':
				$labels = $this->get_root_category_list($this->get_value('root_categoryid'));
				foreach($this->str2ar($value) as $key) {
					$r[$key] = $labels[$key];
				}
				return $r;
			case 'keys':
				return implode('',$this->str2ar($value));
			case 'labels':
				$labels = $this->get_root_category_list($this->get_value('root_categoryid'));
				foreach($this->str2ar($value) as $key) {
					$r .= $labels[$key];
				}
				return $r;
			case 'category_linage':
				$tree = &$this->get_category_tree();
				$stop_point = ($this->get_value('category_lineage_from_attr_root')) ? $this->get_value('root_categoryid') : 0;
				foreach($this->str2ar($value) as $key) {
					$r .= $tree->get_lineage($key, ' &gt; ', $stop_point);
				}
				return $r;
			case 'keys_space':
				return implode(' ',$this->str2ar($value));
			case 'labels_space': default:
				$labels = $this->get_root_category_list($this->get_value('root_categoryid'));
				foreach($this->str2ar($value) as $key) {
					$r .= ' '.$labels[$key];
				}
				return ltrim($r);

			case 'category_linage_space':
				$tree = &$this->get_category_tree();
				$stop_point = ($this->get_value('category_lineage_from_attr_root')) ? $this->get_value('root_categoryid') : 0;
				foreach($this->str2ar($value) as $key) {
					$r .= ' '.$tree->get_lineage($key, ' &gt; ', $stop_point);
				}
				return $r;
			case 'keys_nl':
				return implode("\n",$this->str2ar($value));
			case 'labels_nl':
				$labels = $this->get_root_category_list($this->get_value('root_categoryid'));
				foreach($this->str2ar($value) as $key) {
					$r .= "\n".$labels[$key];
				}
				return ltrim($r);

			case 'category_linage_nl':
				$tree = &$this->get_category_tree();
				$stop_point = ($this->get_value('category_lineage_from_attr_root')) ? $this->get_value('root_categoryid') : 0;
				foreach($this->str2ar($value) as $key) {
					$r .= "\n".$tree->get_lineage($key, ' &gt; ', $stop_point);
				}
				return $r;
			case 'keys_br':
				return implode('<br />',$this->str2ar($value));
			case 'labels_br':
				$labels = $this->get_root_category_list($this->get_value('root_categoryid'));
				foreach($this->str2ar($value) as $key) {
					$r .= '<br />'.$labels[$key];
				}
				return substr($r,6);
			case 'category_linage_br':
				$tree = &$this->get_category_tree();
				$stop_point = ($this->get_value('category_lineage_from_attr_root')) ? $this->get_value('root_categoryid') : 0;
				foreach($this->str2ar($value) as $key) {
					$r .= '<br />'.$tree->get_lineage($key, ' &gt; ', $stop_point);
				}
				return $r;
			case 'raw': default:
				return $value;
		}
	}

	 #############################################
	# Prints the interface for filling in a value
	function print_concise_field($prefix,&$value, $add_blank=false) {
		$root_categoryid = $this->get_value('root_categoryid');
		$multiple = $this->get_value('multiple');

		if($multiple) $value = $this->str2ar($value);
		# Lets develope our complete list of unselectable categories
		$rules = $this->get_value('rules');
		$unselectable_categories = array();
		$unselectable_msg = '';
		if (!empty($rules)) {
			foreach($rules as $rule_code => $rule_settings) {
				if ($rule_settings['type'] != 'exclude_cats') continue;
				$exclude_cats = $rule_settings['excluded_categories'];
				$unselectable_msg = $rule_settings['broken_message'];
				if (!empty($exclude_cats)) {
					foreach($exclude_cats as $cid) {
						$unselectable_categories[$cid] = $cid;
					}
				}
			}
		}

		if($this->get_value('style') == 'list') {

			$category_list = $this->get_root_category_list_wsticks($root_categoryid);
			if ($add_blank) {
				$category_list = array('' => '') + $category_list;
			}

			if ($multiple) {
				$html= multiple_combo_box($prefix.'value', $category_list, $value,($this->get_value('width')?'style="width:'.$this->get_value('width').'px"':''),$this->get_value('maxlength'), $this->get_value('height'));
			} else {
				$html = combo_box($prefix.'value',$category_list, $value,($this->get_value('width')?'style="width:'.$this->get_value('width').'px"':''),$this->get_value('maxlength'), $this->get_value('height'));
			}
			if (!empty($unselectable_categories)) {
				foreach($unselectable_categories as $cid) {
					$html = str_replace('<option value="'.$cid.'"', '<option value="'.$cid.'" style="color:#888888"', $html);
				}
			}

			echo $html;
		} else {

			$tree = &$this->get_category_tree();
			$sub_catids = &$tree->childids($root_categoryid);
			if (!empty($sub_catids)) {
				$total_count    = 0;
				$sub_cat_counts = Array();
				$num_sub_cats = count($sub_catids);
				for($i = 0; $i < $num_sub_cats; $i++) {
					# we add 1 because we need to include the current category
					$sub_cat_counts[$i] = 1 + $tree->count_all_descendantids($sub_catids[$i]);
					$total_count += $sub_cat_counts[$i];
				}

				$num_columns = max(1, (int) $this->get_value('columns'));



				# what is going to end up in here is the index from the $sub_catids array 
				# that is to appear in each column, hence the zero index is their for the first column
				$col_start_indexes = Array(0);

				if ($num_columns > 1) {
					$each_column = ceil($total_count / $num_columns);

					$col_count = 0;
					for($i = 0; $i < $num_sub_cats; $i++) {
						$col_count += $sub_cat_counts[$i];
						if ($col_count >= $each_column) {
							$col_count = 0;
							$col_start_indexes[] = $i + 1;
							if (count($col_start_indexes) >= $num_columns) {
								break;
							}
						}
					}# end for
				}

				?>
				<table cellpadding="0" cellspacing="0" border="0">
					<tr>
				<?
				for($col_i = 0; $col_i < $num_columns; $col_i++) {
					?>
						<td valign="top">
					<?

					# we are on the last column ? 
					$col_stop_index = ($col_i == $num_columns - 1) ? count($sub_catids) : $col_start_indexes[$col_i + 1];

					for($i = $col_start_indexes[$col_i]; $i < $col_stop_index; $i++) {
						$this->_print_boxes_category($tree, $prefix, $value, $unselectable_categories, $unselectable_msg, $multiple, $sub_catids[$i]);
					}#end for
					?>
					</td>
					<?

				}#end for
				?>
					</tr>
				</table>
				<?

			}# end if

		}# end if

	}# end print_consise_field()


	/**
	* Recursivley prints out individual categories when using the boxes style option. Called from print_consise_field()
	*
	* @param  object Category_Tree	&$tree						The notitia category tree object
	* @param  string				$prefix						the form prefix to place in from of all form field names
	* @param  mixed					$value						the current value for this attribute has
	* @param  array(int)			$unselectable_categories	Array of cat ids for cats that cannot be selected
	* @param  string				$unselectable_msg			msg to display for cat's that are not selectable
	* @param  boolean				$multiple_selection			whether checkboxes or radio boxes are used
	* @param  int					$categoryid					the id of the category to print an interface for
	* @param  int					$depth						our current depth in the recursion cycle - used to indent children
	*
	* @access private
	* @return void
	*
	* @see print_consise_field()
	*/
	function _print_boxes_category(&$tree, $prefix, $value, $unselectable_categories, $unselectable_msg, $multiple_selection, $categoryid, $depth=0) {
		if(!$categoryid) $categoryid = 0;

		static $blank_img = null;
		if (is_null($blank_img)) $blank_img = '<img src="'.lib_href('images/blank.gif').'" height="1" width="7" alt="spacer" />';

		?>
		<table cellpadding="0" cellspacing="0" border="0">
			<tr>
		<?
		for($i = 0; $i < $depth; $i++) {
			echo '<td>'.$blank_img.'</td>';
		}

		# If they are not allowed to select the category don't let them
		# we do this in JS, but if they have that turned off, the processing rule will catch it
		$extra = '';
		if (in_array($categoryid, $unselectable_categories)) {
			$msg   = str_replace(Array("\r", "\n"), Array('', '\n'), addslashes($unselectable_msg));
			$extra = 'style="visibility: hidden;" onClick="javascript: alert(\''.$msg.'\'); this.checked = false;"';
		}

		if($multiple_selection) {
			echo '<td valign="middle"><input type="checkbox" name="'.$prefix.'value[]" value="'.$categoryid.'" '.((in_array($categoryid,$value))?' checked':'').' '.$extra.'></td>';

		} else {
			echo '<td valign="middle"><input type="radio" name="'.$prefix.'value" value="'.$categoryid.'" '.(($categoryid == $value)?' checked':'').' '.$extra.'></td>';

		}#end if

		$bold = ($depth == 0 && $this->get_value('top_level_cats_bold'));

		echo '<td valign="middle">&nbsp;'.(($bold) ? '<b>' : '').$tree->name($categoryid).(($bold) ? '</b>' : '').'</td>';

		?>
			</tr>
		</table>
		<?

		$childids = &$tree->childids($categoryid);
		$result = array();
		foreach($childids as $childid) {
			$this->_print_boxes_category($tree, $prefix, $value, $unselectable_categories, $unselectable_msg, $multiple_selection, $childid, $depth+1);
		}
	}# end _print_boxes_category()


	 #############################################
	# Prints the interface for filling in a value
	function print_field($prefix,&$value) {
		$this->print_concise_field($prefix,$value);
		if($note = &$this->get_value("note")) {
			echo '<span class="smallprint"><br />'.$note.'</span>';
		}
	}

	/**
	* Processes changes to an attribute
	*
	* @param  string  $prefix                 The attribute changing prefix
	* @param  &string $value_destination      The current value
	* @param  string  $format                 Don't remember
	* @param  &string &$rules_broken_messages Var to hold broken rull messages
	* @access public
	* @return string
	*/
	function process_field($prefix, &$value_destination, $format, &$rules_broken_messages) {
		$input = $_REQUEST[$prefix.'value'];
		$input = gpc_stripslashes($input);
		if(is_array($input)) {
			$input = $this->ar2str($input);
		}
		if($value_destination == $input) return;
		$this->validate_value($input, $rules_broken_messages);
		if ($rules_broken_messages) {
			# Return nothing so value isn't saved if a rule has been broken
			return 'Rule broken in attribute '.$this->attribute->name.'. '.$rules_broken_messages;
		} else {
			$value_destination = $input;
			return $this->attribute->name.' updated.';
		}
	}

	/**
	* Returns a list of categories, with sticks for selecting the base category with
	*
	* @access public
	* @return array
	*/
	function get_root_category_list_wsticks($rootid=0) {
		$tree = &$this->get_category_tree();
		if ($rootid == 0) {
			return array($rootid => '[The Notitia Category Root]') + $tree->get_category_list_with_sticks($rootid,100);
		} else {
			return $tree->get_category_list_with_sticks($rootid,100);
		}
	}

	/**
	* Returns a list of categories for selecting the base category with
	*
	* @access public
	* @return array
	*/
	function get_root_category_list($rootid=0) {
		$tree = &$this->get_category_tree();
		if ($rootid == 0) {
			return array($rootid => '[The Notitia Category Root]') + $tree->get_category_list($rootid, 100);
		} else {
			return $tree->get_category_list($rootid, 100);
		}
	}

	/**
	* Checks the value is valid
	*
	* @param  string &$value            The value we need to check against the rules
	* @param  string &$rule_broken_msgs The broken rule messages
	* @access public
	* @return void
	*/
	function validate_value(&$value, &$rule_broken_msgs) {
		# Check for rules so we need the rules array
		$this->validate_value_rules($value, $rule_broken_msgs);

		# Do normal checks
		$root_categoryid = $this->get_value('root_categoryid');
		$category_list = $this->get_root_category_list($root_categoryid);
		$value_array = explode('|',$value);
		for(reset($value_array); is_int($k = key($value_array)); next($value_array)) {
			$v = &$value_array[$k];
			if(!isset($category_list[$k])) {
				if(($nk = array_search($v, $category_list)) !== false) {
					$v = $nk;
				}
			}
		}
		$value = $this->ar2str($value_array);
	}

	 ###################################################
	# Returns a query object which can be given back to
	# print_search_field() or get_search_sql_clause()
	function &process_search_field($prefix,$format,$not_null) {
		$tmp = $this->parameters['multiple'];
		$this->parameters['multiple'] = 1;
		$this->process_field($prefix.'q',$q);
		$this->parameters['multiple'] = $tmp;
		if(is_array($q)) return $this->ar2str($q);
		return $q;
	}

	 ##############################################
	# Returns an SQL WHERE subclause for searching
	function get_search_sql_clause($query,$format,$value_string='v.value') {
		switch($format) {
			case 'exact': case 'match': case '_match':
				$cmp = 'STRCMP('.$value_string.',"'.addslashes($query).'")=0';
				break;
			case 'subset': case 'intersect': case 'partial': case '_partial':
				$cmp = '0='.(($format=='intersect')?'1':'0');
				foreach(explode('|',$query) as $e) {
					$cmp .= (($format=='intersect')?' OR':' AND').' CONCAT(\'|\','.$value_string.',\'|\') LIKE "%|'.$e.'|%"';
				}
				break;
			case 'exactsubcat':
				$cmp = '0=1';
				foreach(explode('|',$query) as $e) {
					$cmp .= ' '.'OR'.' STRCMP('.$value_string.',"'.addslashes($e).'")=0';
					$tree = &$this->get_category_tree();
					$cat_list = $tree->get_category_list($e,100);
					foreach (array_keys($cat_list) as $categoryid) {
						$cmp .= ' '.'OR'.' STRCMP('.$value_string.',"'.addslashes($categoryid).'")=0';
					}
				}
				break;
			case 'subsetsubcat':
				$cmp = '0=1';
				foreach(explode('|',$query) as $e) {
					$cmp .= ' '.'OR'.' CONCAT(\'|\','.$value_string.',\'|\') LIKE "%|'.$e.'|%"';
					$tree = &$this->get_category_tree();
					$cat_list = $tree->get_category_list($e,100);
					foreach (array_keys($cat_list) as $categoryid) {
						$cmp .= ' '.'OR'.' CONCAT(\'|\','.$value_string.',\'|\') LIKE "%|'.$categoryid.'|%"';
					}
				}
				break;
		}
		return $cmp;
	}


	 ##############################################
	# Returns an SQL expression that evalutates a clause
	function get_search_sql_score($query,$format,$value_string='v.value') {
		switch($format) {
			case 'exact':
				return 1;
			case 'subset': case 'intersect':
				$cmp = '0';
				foreach(explode('|',$query) as $e) {
					$cmp .= '+ CONCAT(\'|\','.$value_string.',\'|\') LIKE "%|'.$e.'|%" / '.count($query);
				}
				return $cmp;
			case 'exactsubcat': case 'subsetsubcat':
				return 1;
		}
	}

	 ###########################
	# Prints out a search field
	function print_search_field($prefix,&$default,$format,$not_null) {
		switch($format) {
			case 'exact': case 'subset': case 'exactsubcat': case 'subsetsubcat':
				$this->print_concise_field($prefix.'q',$default, true);
				break;
			case 'intersect':
				$tmp = $this->parameters['multiple'];
				$this->parameters['multiple'] = 1;
				$this->print_concise_field($prefix.'q',$default);
				$this->parameters['multiple'] = $tmp;
				break;
		}
	}

	/**
	* Sets in the request vars a static search
	*
	* @param   string $prefix Prefix
	* @param   string $value  A value
	* @param   string $format A search format
	* @access  public
	* @returns void
	*/
	function set_search_request($prefix,&$value,$format) {
		if ($format == 'exact' || $format == 'subset' || $format == 'intersect') {
			if ($format == 'intersect') {
				$tmp = $this->parameters['multiple'];
				$this->parameters['multiple'] = 1;
			}

			$root_categoryid = $this->get_value('root_categoryid');
			$category_list = (($this->get_value('style') == 'boxes')?$this->get_root_category_list($root_categoryid):$this->get_root_category_list_wsticks($root_categoryid));

			if($this->get_value('multiple')) $value = $this->str2ar($value);
			if($this->get_value('style') == 'list') {
				$_REQUEST[$prefix.'qvalue'] = $value;
			} else {
				reset($category_list);
				$i = 0;
				while(list($key,$val) = each($category_list)) {
					if($this->get_value('multiple')) {
						if (in_array($key,$value)) {
							$_REQUEST[$prefix.'qvalue['.$i.']'] = $key;
						}
					} else {
						if ($key == $value) {
							$_REQUEST[$prefix.'qvalue'] = $key;
						}
					}
					$i++;
				}
			}

			if ($format == 'intersect') {
				$this->parameters['multiple'] = $tmp;
			}
		}
	}

	/**
	* Returns a reference to the notitia system
	*
	* @access public
	* @return &object
	*/
	function &get_notitia_system() {
		$web_system = &get_web_system();
		return $web_system->get_extension('notitia');
	}

	/**
	* Gets the category object
	*
	* @param int $categoryid The id of the category
	* @access public
	* @return &object
	*/
	function &get_category($categoryid) {
		$e = &$this->get_notitia_system();
		return $e->get_category($categoryid);
	}

	/**
	* Returns a reference to an object
	*
	* @access public
	* @return &object
	*/
	function &get_category_tree() {
		$e = &$this->get_notitia_system();
		return $e->get_category_tree();
	}

	/**
	* Returns the basic new settings for the exclude categories rules
	*
	* @access public
	* @return array
	*/
	function get_new_rule_exclude_cats_settings() {
		return array('type' => 'exclude_cats', 'name' => 'Categories Unselectable', 'broken_message' => 'You cannot select this category', 'excluded_categories' => array());
	}

	/**
	* Returns the interface for the excluded cats
	*
	* @param  string $interface_name The basic name of the interface
	* @param  array  $rule_settings  The settings for the rule in question
	* @access public
	* @return string
	*/
	function get_rule_exclude_cats_interface($interface_name, $rule_settings) {
		$broken_message = text_box($interface_name.'_broken_message', $rule_settings['broken_message'], 40);
		$root_categoryid = $this->get_value('root_categoryid');
		$category_list = $this->get_root_category_list_wsticks($root_categoryid);
		$excluded_categories_combo = multiple_combo_box($interface_name.'_exclude_cats', $category_list, $rule_settings['excluded_categories'], '', '', 5);
		$interface  = '<table bgcolor="#AAAAAA">';
		$interface .= '	<tr bgcolor="#DDDDDD">';
		$interface .= '		<td><i>Rule Broken Message</i></td><td>'.$broken_message.'</td>';
		$interface .= '	</tr>';
		$interface .= '	<tr bgcolor="#DDDDDD">';
		$interface .= '		<td><i>Disallowed Categories</i></td><td>'.$excluded_categories_combo.'</td>';
		$interface .= '	</tr>';
		$interface .= '</table>';
		return $interface;
	}

	/**
	* Processes any changes to the excluded cats
	*
	* @param  string $interface_name The basic name of the interface
	* @param  array  &$rule_settings  The settings for the rule in question
	* @access public
	* @return string
	*/
	function process_rule_exclude_cats_interface($interface_name, &$rule_settings) {
		$msgs = '';
		if ($_POST[$interface_name.'_broken_message'] != $rule_settings['broken_message'] && isset($_POST[$interface_name.'_broken_message'])) {
			$rule_settings['broken_message'] = $_POST[$interface_name.'_broken_message'];
			$msgs .= 'Broken rule message has been updated<br />';
		}
		if ($_POST[$interface_name.'_exclude_cats'] != $rule_settings['excluded_categories'] && isset($_POST[$interface_name.'_exclude_cats'])) {
			$rule_settings['excluded_categories'] = $_POST[$interface_name.'_exclude_cats'];
			$msgs .= 'Excluded categories has been modified<br />';
		}
		return $msgs;
	}

	/**
	* Validating must link x value
	*
	* @param  string $value         The value we need to check against the rule
	* @param  array  $rule_settings The settings of the rule we are checking against the value
	* @access public
	* @return string
	*/
	function validate_exclude_cats_rule($value, $rule_settings) {
		if ($value) {
			$r = explode('|', $value);
		} else {
			$r = array();
		}

		$excluded_categories = $rule_settings['excluded_categories'];
		$msg = '';
		if (array_any_common_elements($excluded_categories, $r)) {
			$msg = $rule_settings['broken_message'];
		}
		return $msg;
	}
}
?>