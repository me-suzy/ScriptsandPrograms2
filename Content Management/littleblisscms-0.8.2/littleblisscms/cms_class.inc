<?php
/*
	Copyright (C) 2005  Phillip Berry (Bliss Webhosting)
	
	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/
/*!
* \var Whether or not to always display an 'edit' link. if false a login link must be provided
*/
define(DISPLAY_EDIT_LINKS,FALSE) ;

/*! \mainpage LittleBlissCMS
*
* \section intro_sec Introduction
*
* LittleBlissCMS handles moving content generated by TinyMCE to and from an xml text file, ensures content managers have permission to edit any particular section 
*and allows content managers to be managed.
*
* The cms_class class handles all the higher level activites pertaining to the content, users and permissions \n
* The authentication Class handles basic authentiction (login) \n
* The xml_handler class manages data transfer and fetching from the xml file \n
* \n
* There is definately some cleaning up to be done, some logic paths are strange, but it all works at the moment...
*/
/*Class handles content management*/
require_once("xml_handler_class.inc") ;
class cms_class extends xml_handler{
	
	var $error = FALSE ;
	var $edit_id = FALSE ;
	var $section_id = FALSE;
	var $content = FALSE ;
	var $update = FALSE ;
	var $new_content = FALSE ;
	var $section_node = FALSE ;	
	var $section_permission = TRUE ;
	var $content_managers = FALSE ;	
	
	/*!
	* \brief Constructor creates dom from defined file
	* \param $xmlfile String, Path to xmlfile
	*/
	function cms_class($xmlfile){
		parent::xml_handler($xmlfile) ;
	}

	/*!
	* \brief Function is used to display a static section
	* \return String
	*/
	function display_static_section($section){		
		return $this->display_content($section,"static") ;
	}
	
	/*!
	* \brief Function is used to display a dynamic section
	* \return String
	*/
	function display_dynamic_section($section){		
		return $this->display_content($section,"dynamic") ;
	}

	/*!
	* \brief Function retrieves the content belonging to the defined section and returns it. If the edit variable is false it appends the 'edit' link to the content to be returned
	* \param $section_id String, Section to display
	* \param $section_type String, Type of section being displayed, either dynamic or static
	* \return False or String Data to be displayed
	*/
	function display_content($section_id,$section_type){
		$this->content = "" ;
		$this->section_id = $section_id ;
		$edit = $_GET['edit'] ;

		if($this->find_section($this->section_id)){
			if(!$this->content && $this->error){
				$this->content = $this->error ;
			}
			if($edit == $section_id && $this->check_edit_permission($_SESSION['username'],$section_id)){
				return $this->display_tinymce_form($this->section_id,$section_type) ;
			}else{
				if(DISPLAY_EDIT_LINKS || $this->check_edit_permission($_SESSION['username'],$section_id)){
					$this->content.="\n<a style=\"font-size:8px ;\" href=\"".$_SERVER['PHP_SELF']."?edit=".$section_id."&section_type=".$section_type."\">Edit</a>" ;
				}
				return stripslashes($this->content) ;
			}
		}else{
			if(!$this->content && $this->error){
				$this->content = $this->error ;
			}
			if(!$edit){
				if(DISPLAY_EDIT_LINKS || isset($_SESSION['authenticated'])){
					$this->content .= "\n<a href=\"".$_SERVER['PHP_SELF']."?edit=".$section_id."&section_type=".$section_type."\">Edit</a>" ;
				}
				return $this->content ;
			}else{
				return $this->display_tinymce_form($this->section_id) ;
			}
		
		}
		$this->error = "Cannot  find section '".$section_id ;
		return FALSE ;
	}

	/*!
	* \brief Function returns the Tinymce form filled with the contents of the defined section
	* \param $section String, Name of the section to populate the text area with
	* \param $section String, Section Type dynamic or static
	* \return False or String HTML Form data
	*/
	//Text field 'content' = editable content
	//Two hidden fields 'id' = current section being edited, 'referrer' = the current page.
	function display_tinymce_form($section,$section_type=FALSE){		
		$content = stripslashes($this->content) ;
		$form = "<form method=\"post\" action=\"/littleblisscms/processor.php\">
				<textarea name=\"content\" cols=\"105\" rows=\"80\" style=\"background-color:#FFFFFF\">
				$content
				</textarea>
					<input type=\"hidden\" name=\"id\" value=\"".$section."\">
					<input type=\"hidden\" name=\"section_type\" value=\"".$section_type."\">
					<input type=\"hidden\" name=\"referrer\" value=\"".$_SERVER['SERVER_NAME'].$_SERVER['PHP_SELF']."\">
					<input type=\"submit\">
				</form>" ;
		return $form ;	
	}	

	/*!
	* \brief Function outputs the html head data with the tinyMCE script intialiser
	* \return String
	*/
	function head($head=NULL){
		$head = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">
					<html>
					<head>
						<title>LittleBlissCMS</title>
						<META HTTP-EQUIV=\"Content-type\" CONTENT=\"text/html; charset=UTF-8\">						
						<META NAME=\"keywords\" CONTENT=\"CMS, XML, simple, content, management, littleblisscms, lbcms\">
						<META NAME=\"description\" CONTENT=\"The LittleBlissCMS (LBCMS) is a lightweight CMS that uses Moxiecodes TinyMCE as an in-browser WYSIWYG editor\">
						<META NAME=\"author\" CONTENT=\"Phillip Berry\">
						<META NAME=\"ROBOTS\" CONTENT=\"ALL\">
						<link rel=\"stylesheet\" type=\"text/css\" href=\"/main.css\">\n" ;
		if(isset($_GET['edit'])){
			$head.= $this->tinymce_init() ;
		}
		$head .= "</head>" ;
		return $head ;
	}	

	/*!
	* \brief Function outputs the tinymce init data 
	* \return String
	*/
	function tinymce_init(){
		if($_GET['edit']){
			//Insert the TinyMCE javascript
			$tinymce= "<script language=\"javascript\" type=\"text/javascript\" src=\"/littleblisscms/tiny_mce/tiny_mce.js\"></script>
						<script language=\"javascript\" type=\"text/javascript\">
							tinyMCE.init({
								theme : \"advanced\",
								mode : \"textareas\",
								content_css : \"/main.css\",
								verify_html : true,
								visual : true,
								plugins : \"table,advimage,save,preview\",
								theme_advanced_buttons1_add_before : \"save,preview,separator\",
								theme_advanced_buttons2 : \"tablecontrols,separator\",
								theme_advanced_buttons3 : \"bullist,numlist,separator,outdent,indent,separator,undo,redo,separator,link,unlink,anchor,image,cleanup,help,code,hr,removeformat,visualaid,separator,sub,sup,separator,charmap\",
								plugin_preview_width : \"500\",
								plugin_preview_height : \"600\",
								theme_advanced_toolbar_align : \"left\",
								theme_advanced_toolbar_location : \"top\"
							});
						</script>\n\n" ;
			return $tinymce ;
		}
	}

	/*!
	* \brief Function displays either a login link or logout link
	* \return String
	*/
	function display_auth_link(){
		$login = "<div id=\"login\">
					<a href=\"".$_SERVER['PHP_SELF']."?edit=login\">Login</a>
				</div>" ;
		$logout = "<div class=\"content\" id=\"login\">
					<a href=\"/littleblisscms/processor.php?action=logout\">Logout</a>
				</div>" ;
		if(isset($_SESSION['authenticated'])){
			return $logout ;
		}
		else{
			return $login ;
		}
	}

	/*!
	* \brief Function sets the section to be displayed, section can be set through various sources
	* \param $default String, Default section to be displayed
	* \return String section to be displayed or edited
	*/
	function set_dynamic_section($default){
		$section = $default ;
		//Set the section type if the section is dynamic
		if($_GET['section'] && $_GET['section_type'] != 'static'){
			$section = $_GET['section'] ;
		//Check if the edited section is dynamic
		}elseif(isset($_GET['edit']) && $_GET['section_type'] == 'dynamic') {
			$section = $_GET['edit'] ;
		}
		
		return $section ;
	}

	/*!
	* \brief Function checks if the page is being edited and does some initial auth checking	
	* \param[out] $edit_id String, Set class edit_id var
	* \return False or TinyMCE javascript
	*/
	function test_editing(){
		session_start() ;
		if($_GET['edit']){
			$this->edit_id = $_GET['edit'] ;
			//Popup the login box if the user has not logged in
			if(!$_SESSION['authenticated']){
				$this->login_box() ;
				exit() ;
			}
			//Check if the user has edit permissions to the section
			elseif(!$this->check_edit_permission($_SESSION['username'],$_GET['edit'])){
				$this->error = "Insufficient permissions to edit section" ;
				return FALSE ;
			}
			else{
				return TRUE ;
			}
		}
		return FALSE ;
	}

	/*!
	* \brief Function retrieves the content managers for the section being edited and if the user exists tests the users permissions.
	* \param[in] $username String, Username to test
	* \param[in] $section_id String, Section to test
	* \param[out] $section_permission bool, class wide variable	
	* \param[out] $error
	* \return bool
	*/
	function check_edit_permission($username,$section_id){
		if($username == "administrator"){
			$this->section_permission = TRUE ;
			return TRUE ;
		}
		elseif($this->find_section($section_id)){
			$managers = explode(":",$this->content_managers) ;
			foreach($managers as $manager){
				if($username == trim($manager)){
					$this->section_permission = TRUE ;
					return TRUE ;
				}
			}			
			$this->section_permission = FALSE ;
			$this->error = "Insufficient permissions to edit section" ;
			return FALSE ;
		}
		$this->error = "Section does not exist" ;
		return FALSE ;
	}

	/*!
	* \brief Function pops up the "form.html" login box
	* \return bool
	*/
	function login_box(){
		echo "<html>\n<head>
				<script language=\"javascript\" type=\"text/javascript\">\n
					window.open(\"/littleblisscms/form.html\",\"_blank\",\"toolbar=no, location=no, directories=no, status=no, titlebar=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=250, height=160\")
				</script>
			</head><body></body></html>\n\n" ;
		return TRUE ;	
	}

	/*!
	* \brief Function outputs an error if an error exists
	*/
	function output_error(){
		if($this->error){
			echo $this->error ;
		}
	}	

	/*! 
	* \brief Function updates the defined sections content.
	* \param[in] $section_id String, Section to be updated
	* \param[in] $content String, New content
	* \param[out] $section_id String,  Class wide var
	* \param[out] $new_content String, Class wide var
	* \return bool
	*/
	function update_content($section_id,$content){		
		$this->section_id = $section_id ;
		$this->new_content = $content ;
		//Create the new content file
		$this->generate_content_xml_string($content) ;
		$this->write_xml_file() ;
		if($this->error){
			return FALSE ;
		}
		else{
			return TRUE ;
		}
	}		


	/*!
	* \brief Function searches for a section and places its data into vars if it exists
	* \param[in] $id String Section
	* \param[out] $section_node DomNode, Class wide domnode
	* \param[out] $content String, Class wide hex2asc Converted HTML
	* \param[out] $content_managers String, Classwide string of content managers
	* \return bool
	*/
	function find_section($id){
		$tags = $this->find_tag("section") ;
		foreach($tags as $section){
			if($this->search_attribute_value($section,"id",$id)){
				$this->section_node = $section ;
				$node_array = $this->retrieve_node_data($this->section_node) ;
				$this->content = $this->hex2asc($node_array['content']['data']) ;
				$this->content_managers = $node_array['content_managers']['data'] ;
				return TRUE ;
			}
		}
		return FALSE ;
	}
	
	/*!
	* \brief removes the defined content "section"
	* \param[in] $section String, Name of section to delete
	* \param[out] $xml String, , New dom tree for writing
	* \return bool
	*/
	function delete_section($section){
		if($this->delete_tag("section",$section)){
			$this->xml = $this->dom->dump_mem();
			if($this->write_xml_file()){
				return TRUE ;
			}
		}
		return FALSE ;
	}

	/*!
	* \brief Function alters the content managers assigned to a content section	
	* \param[in] $user String, Username to modify
	* \param[in] $section String, Section to modify
	* \param[in] $action String, "Add" or "Remove" Action to take
	* \param[out] $xml String, , New XML to write
	* \return bool
	*/
	function alter_section_permission($user,$section,$action){
		$managers = $this->retrieve_content_managers($section);
		$i = 0 ;
		$new_manager_str = "" ;

		//If there is more than one manager
		if(is_array($managers)){
			if($action == "add"){
				$managers[] = $user ;
			}
			elseif($action == "remove"){
				$key = array_search($user,$managers) ;
				unset($managers[$key]) ;
			}
			foreach($managers as $manager){
				//If there is more than one manager delimit them wiht colons
				if($i > 0 && $i < count($managers)){
					$new_manager_str .= ":" ;
				}
				$new_manager_str .= $manager ;
				$i++ ;
			}
		}
		else{
			if($action == "add"){
				if($managers == ""){
					$new_manager_str = $user ;	
				}
				else{
					$new_manager_str = str_replace("::",":",$managers.":".$user) ;
				}
			}
			elseif($action == "remove"){
				if($user == $managers){
					$new_manager_str = "" ;
				}
				else{
					return FALSE ;
				}
			}
		}
				
		if($this->find_section($section)){
			//Update contentmanagers node
			$this->update_node_data($this->section_node,$new_manager_str,"content_managers") or $this->error = "Could not update content" ;
			//Output domtree
			$this->xml = $this->dom->dump_mem();
			return TRUE ;
		}
		else{
			return FALSE ;
		}

	}

	/*!
	* \brief Function extracts all of the contents in the content file, strips the html contents down to 100 characters
	* \return $data Array Multidimensional Array	
	*/
	function extract_contents(){
		$data = $this->extract_all_data() ;		
		foreach($data as $key => $row) {
			if(is_array($row)){
				foreach($row as $sub_key => $sub_row) {
					if($sub_key == "content"){
						$data[$key][$sub_key] = substr($this->hex2asc($sub_row)."........",0,100) ;
					}
				}
			}
		}
		return $data ;
	}

	/*!
	* \brief Retrieve all content data into an array
	* \return $content Array
	* 	- $content array is structured \n
	*		-$content[section][content] \n
	*		-$content[section][content_managers][Array of managers]
	*/
	function retrieve_all_data(){
		$array ;
		$content = $this->extract_all_data();
		foreach($content as $key => $data){
			if(is_array($data)){
				foreach($data as $sub_key => $sub_data){
					if($sub_key == "content"){
						$content[$key][$sub_key] = $this->hex2asc($sub_data) ;
					}
					elseif($sub_key == "content_managers"){
						if(strpos($sub_data,":")){
							$managers = explode(":",$sub_data) ;
							foreach($managers as $man_key => $manager){
								$managers[$man_key] = trim($manager) ;
							}
							$content[$key][$sub_key] = $managers ;
						}
					}
				}
			}
		}		
		return $content ;
	}

	/*!
	* \brief Function retrieves a defined sections data
	* \param $section String, Section Name
	* \return False or Array
	*/
	function retrieve_section_data($section){
		$array = $this->retrieve_all_data() ;
		if(is_array){
			foreach($array as $key => $data){
				if($key == $section){
					return $section_array[] = $data ;
				}
			}
		}
		return FALSE ;
	}

	/*!
	* \brief Function retrieves the content managers for a defined section
	* \param $section String, Section Name
	* \return Array
	*/
	function retrieve_content_managers($section){
		$section_array = $this->retrieve_section_data($section) ;		
		return $section_array['content_managers'] ;
	}

	/*!
	* \brief Function returns an array of all the content section names
	* \return Array
	*/
	function retrieve_section_names(){
		$section_array ;
		$array = $this->retrieve_all_data() ;
		foreach($array as $key => $data){
			$section_array[] = $key ;
		}
		return $section_array ;
	}

	/*!
	* \brief Function generates the XML for the content file
	* \param[in] $content String, HTML Data
	* \param[out] $xml String, XML Data
	* \return bool
	*/
	function generate_content_xml_string($content){
		//If the section being edited exists theen use the udpate_section function
		if($this->find_section($this->section_id)){
			$this->update_node_data($this->section_node,$this->asc2hex($content),"content") or $this->error = "Could not update content" ;;
		}
		else{
			//If it is a new section create the tree 
			//format: 
			//<section id='sectionname'>
				//<content>hexencoded content</content>
				//<content_managers>colon ':' separated list</content_managers>
			//</section>
			$this->section_node = $this->dom->create_element("section") ;
			$this->section_node = $this->root->append_child($this->section_node) ;
			$this->section_node->set_attribute("id",$this->section_id) ;
			$content_node = $this->dom->create_element("content") ;
			$content_node = $this->section_node->append_child($content_node) ;
			$content_node->set_content($this->asc2hex($this->new_content)) ;
			$content_managers_node = $this->dom->create_element("content_managers") ;
			$content_managers_node = $this->section_node->append_child($content_managers_node) ;
			$content_managers_node->set_content("administrator") ;
		}
		if(!$this->error){
			//Create the output xml
			$this->xml = $this->dom->dump_mem();
			return TRUE ;
		}
		return FALSE ;
	}	

/**********************************USER ADMIN FUNCTIONS********************************/
	/*!
	* \brief Creates a new user
	* \param[in,out] $new_username String, Username
	* \param[in,out] $new_password String, Password
	* \param[out] $xml String, , New XML for file
	* \return bool
	*/
	function new_user($new_username,$new_password){
		if(!$new_username && !$new_password){
			$this->error = "No username or password supplied" ;
			return FALSE ;
		}
		$this->new_username = $new_username;
		$this->new_password = $new_password ;
		$this->generate_auth_xml_string() ;
		$this->write_xml_file() ;
		return TRUE ;
	}	

	/*!
	* \brief Function deletes a user
	* \param[in] $username String, Username
	* \param[out] $xml, New XML for file
	* \return bool	
	*/
	function delete_user($username){
		if($this->delete_tag("user",$username)){
			$this->xml = $this->dom->dump_mem();
			if($this->write_xml_file()){
				return TRUE ;
			}
		}
		return FALSE ;
	}

	/*!
	* \brief Removes a user from all contentmanager elements
	* \param[in] $username String, Username
	* \param[out] $error String
	* \param[out] $xml String, XML for file write
	* \return bool
	*/
	function remove_user_all_sections($username){
		$section_names = $this->retrieve_section_names() ;
		foreach($section_names as $section_name){
			if(!$this->alter_section_permission($username,$section_name,"remove")){
				$this->error = "Could not remove user from section" ;
				return FALSE ;
			}
		}
		$this->xml = $this->dom->dump_mem();
		return TRUE ;
	}

	/*!
	* \brief Function changes a users password (passwords are md5 salted with the username)
	* \param[in] $username String, Username
	* \param[in] $password String, New Password
	* \param[out] $xml String, XML for file
	* \param[out[ $error String
	* \return bool
	*/
	function change_password($username,$password){
		if($this->find_user($username)){
			if($this->update_node_data($this->user_node,md5($username.$password),"password")){
				//Output domtree
				$this->xml = $this->dom->dump_mem();
				return TRUE ;
			}
			else{
				$this->error = "Could not update users password" ;
				return FALSE ;
			}
		}
		return FALSE ;
	}

	/*!
	* \brief Function searches for a user and set a class var to the users DomNode
	* \param[in] $find_user String, Username
	* \param[out] $user_node DomNode, users domnode
	* \return bool
	*/
	function find_user($username){
		$tags = $this->find_tag("user") ;
		foreach($tags as $user){
			if($this->search_attribute_value($user,"username",$username)){
				$this->user_node = $user ;
				return TRUE ;
			}
		}
		return FALSE ;
	}	

	/*!
	* \brief Function generates the initial user xml structure if none exists
	* \param[out] $error String
	* \param[out] $xml, String
	* \TODO scope variables, password_node
	*/
	
	function generate_auth_xml_string(){
		if($this->find_user($this->new_username)){
			$this->error = "Username already exists" ;
			return FALSE ;
		}
		
		//format: 
		//<user username='username'>
			//<password>md5 hash of "user.password"</password>
		//</user>
		$this->user_node = $this->dom->create_element("user") ;
		$this->user_node = $this->root->append_child($this->user_node) ;
		$this->user_node->set_attribute("username",$this->new_username) ;
		$this->password_node = $this->dom->create_element("password") ;
		$this->password_node = $this->user_node->append_child($this->password_node) ;
		//Set password to salted md5hash
		$this->password_node->set_content(md5($this->new_username.$this->new_password)) ;

		//Output domtree
		$this->xml = $this->dom->dump_mem();
	}

}



?>