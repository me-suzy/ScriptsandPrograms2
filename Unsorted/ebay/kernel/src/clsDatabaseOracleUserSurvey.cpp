/*	$Id: clsDatabaseOracleUserSurvey.cpp,v 1.4 1998/12/06 05:32:04 josh Exp $	*/
//
//	File:	clsDatabaseUserSurvey.cpp
//
//	Class:	clsDatabaseOracle
//
//	Author:	Michael Wilson (michael@ebay.com)
//
//	Function:
//		Methods relating to user surveys.
//
// Modifications:
//				- 10/25/97 michael	- Created

#include "eBayKernel.h"

//
// AddManyUsers
//
//	This method is intended purely as a migration
//	tool for loading an existing database of users
//	into the system. 
//
//	It accepts arrays of information which must
//	conform to Oracle's array processing spec --
//	namely that all array elements are of equal 
//	length. 
//
//	Ids are generated by using a sequence, rather 
//	than letting the caller assign them
//
static const char *SQL_GetUserSurveyResponse =
 "select	boolean_response,				\
			number_response,				\
			text_response_length,			\
			text_response					\
	from	ebay_user_survey_responses		\
	where		marketplace = :marketplace	\
		and		user_id = :id				\
		and		survey_id = :sid			\
		and		question_id = :qid";


void clsDatabaseOracle::GetUserSurveyResponse(MarketPlaceId marketplace,
											  int user_id,
											  int survey_id,
											  int question_id,
											  bool *pGotBoolResponse,
											  bool *pBoolResponse,
											  bool *pGotNumberResponse,
											  float *pNumberResponse,
											  bool *pGotTextResponse,
											  int *pTextResponseLength,
											  char **ppTextResponse)
{
	char		boolResponse[2];
	sb2			boolResponse_ind		= 0;
	float		numberResponse;
	sb2			numberResponse_ind		= 0;
	int			textResponseLength;
	sb2			textResponseLength_ind	= 0;
	char		textResponse[512];
	sb2			textResponse_ind		= 0;

	// Do our cursor thing
	OpenAndParse(&mpCDAOneShot, SQL_GetUserSurveyResponse);

	// Now, the binds
	Bind(":marketplace", &marketplace);
	Bind(":id", &user_id);
	Bind(":sid", &survey_id);
	Bind(":qid", &question_id);

	Define(1, boolResponse, sizeof(boolResponse),
			&boolResponse_ind);
	Define(2, &numberResponse, &numberResponse_ind);
	Define(3, &textResponseLength, &textResponseLength_ind);
	DefineLongRaw(4, (unsigned char *)textResponse, sizeof(textResponse),
				  &textResponse_ind);


	// Git it
	ExecuteAndFetch();

	// See what we got
	if (boolResponse_ind == -1)
	{
		*pGotBoolResponse	= false;
	}
	else
	{
		*pGotBoolResponse	= true;
		*pBoolResponse		= boolResponse[0] ? true : false;
	}

	if (numberResponse_ind == -1)
	{
		*pGotNumberResponse	= false;
	}
	else
	{
		*pGotNumberResponse	= true;
		*pNumberResponse	= numberResponse;
	}

	if (textResponseLength_ind == -1)
	{
		*pGotTextResponse	= false;
	}
	else
	{
		*pGotTextResponse		= true;
		*pTextResponseLength	= textResponseLength;
		*ppTextResponse			= new char[textResponseLength + 1];
		memcpy(*ppTextResponse, textResponse, textResponseLength);
		*(*ppTextResponse + textResponseLength)	= '\0';
	}

	Close(&mpCDAOneShot);
	SetStatement(NULL);

	return;
}


//
// SetUserSurveyResponse (Boolean)
//
//	This routine will insert, or, if the row is already present,
//	update it. Sooo, the implication here is that if multiple
//	responses aren't allowed, it's up to the client to enforce
//	that.
//
static const char *SQL_InsertBooleanSurveyResponse = 
"insert into ebay_user_survey_responses				\
	(	marketplace,								\
		user_id,									\
		survey_id,									\
		question_id,								\
		boolean_response							\
	)												\
 values												\
	(	:marketplace,								\
		:id,										\
		:sid,										\
		:qid,										\
		:response									\
	)";

static const char *SQL_UpdateBooleanSurveyResponse = 
"update ebay_user_survey_responses					\
	set		boolean_response	= :response			\
	where	marketplace			= :marketplace		\
	and		user_id				= :id				\
	and		survey_id			= :sid				\
	and		question_id			= :qid";

void clsDatabaseOracle::SetUserSurveyResponse(MarketPlaceId marketplace,
											  int user_id,
											  int survey_id,
											  int question_id,
											  bool response)
{
	int		rc;
	char	charResponse[2];


	// Set up the bool, fool
	if (response)
	{
		charResponse[0]	= '1';
	}
	else
	{
		charResponse[0]	= '0';
	}

	charResponse[1]	= '\0';


	// Open....
	OpenAndParse(&mpCDAOneShot,
				 SQL_InsertBooleanSurveyResponse);

	// Bind
	// Now, the binds
	Bind(":marketplace", &marketplace);
	Bind(":id", &user_id);
	Bind(":sid", &survey_id);
	Bind(":qid", &question_id);
	Bind(":response", charResponse);

	// Let's try it...
	// Call oexn directly
	rc	= oexec((cda_def *)mpCDACurrent);

	// If we got a rc == -9 then it's probably an integrity
	// violation, and we need to UPDATE a row, instead of 
	// adding it.
	if (rc == -9)
	{
		// Close the cursor
		Close(&mpCDAOneShot);
		SetStatement(NULL);

		// Open a new one
		OpenAndParse(&mpCDAOneShot,
				 SQL_UpdateBooleanSurveyResponse);

		// Binds
		Bind(":marketplace", &marketplace);
		Bind(":id", &user_id);
		Bind(":sid", &survey_id);
		Bind(":qid", &question_id);
		Bind(":response", charResponse);

		// Do it
		Execute();
	}
	else
	{
		Check(rc);
	}
	// Make the commitment
	Commit();

	// Close the cursor
	Close(&mpCDAOneShot);
	SetStatement(NULL);


	return;
}

//
// SetUserSurveyResponse (Number)
//
//	This routine will insert, or, if the row is already present,
//	update it. Sooo, the implication here is that if multiple
//	responses aren't allowed, it's up to the client to enforce
//	that.
//
static const char *SQL_InsertNumberSurveyResponse = 
"insert into ebay_user_survey_responses				\
	(	marketplace,								\
		user_id,									\
		survey_id,									\
		question_id,								\
		number_response								\
	)												\
 values												\
	(	:marketplace,								\
		:id,										\
		:sid,										\
		:qid,										\
		:response									\
	)";

static const char *SQL_UpdateNumberSurveyResponse = 
"update ebay_user_survey_responses					\
	set		number_response		= :response			\
	where	marketplace			= :marketplace		\
	and		user_id				= :id,				\
	and		survey_id			= :sid,				\
	and		question_id			= :qid";

void clsDatabaseOracle::SetUserSurveyResponse(MarketPlaceId marketplace,
											  int user_id,
											  int survey_id,
											  int question_id,
											  float response)
{
	int		rc;

	// Open....
	OpenAndParse(&mpCDAOneShot,
				 SQL_InsertNumberSurveyResponse);

	// Bind
	// Now, the binds
	Bind(":marketplace", &marketplace);
	Bind(":id", &user_id);
	Bind(":sid", &survey_id);
	Bind(":qid", &question_id);
	Bind(":response", &response);

	// Let's try it...
	// Call oexn directly
	rc	= oexec((cda_def *)mpCDACurrent);

	// If we got a rc == -9 then it's probably an integrity
	// violation, and we need to UPDATE a row, instead of 
	// adding it.
	if (rc == -9)
	{
		// Close the cursor
		Close(&mpCDAOneShot);
		SetStatement(NULL);

		// Open a new one
		OpenAndParse(&mpCDAOneShot,
				 SQL_UpdateNumberSurveyResponse);

		// Binds
		Bind(":marketplace", &marketplace);
		Bind(":id", &user_id);
		Bind(":sid", &survey_id);
		Bind(":qid", &question_id);
		Bind(":response", &response);

		// Do it
		Execute();
	}

	// This Check works for both the insert and update
	// case (though it's redundant in the latter);
	Check(rc);

	// Make the commitment
	Commit();

	// Close the cursor
	Close(&mpCDAOneShot);
	SetStatement(NULL);


	return;
}

//
// SetUserSurveyResponse (Text)
//
//	This routine will insert, or, if the row is already present,
//	update it. Sooo, the implication here is that if multiple
//	responses aren't allowed, it's up to the client to enforce
//	that.
//
static const char *SQL_InsertTextSurveyResponse = 
"insert into ebay_user_survey_responses				\
	(	marketplace,								\
		user_id,									\
		survey_id,									\
		question_id,								\
		text_response_length,						\
		text_response								\
	)												\
 values												\
	(	:marketplace,								\
		:id,										\
		:sid,										\
		:qid,										\
		:lresponse,									\
		:response									\
	)";

static const char *SQL_UpdateTextSurveyResponse = 
"update ebay_user_survey_responses					\
	set		text_response_length= :lresponse,		\
			text_response		= :response			\
	where	marketplace			= :marketplace		\
	and		user_id				= :id,				\
	and		survey_id			= :sid,				\
	and		question_id			= :qid";

void clsDatabaseOracle::SetUserSurveyResponse(MarketPlaceId marketplace,
											  int user_id,
											  int survey_id,
											  int question_id,
											  char *pResponse)
{
	int		rc;
	int		responseLength;

	// Set that length
	responseLength	= strlen(pResponse);

	// Open....
	OpenAndParse(&mpCDAOneShot,
				 SQL_InsertTextSurveyResponse);

	// Bind
	// Now, the binds
	Bind(":marketplace", &marketplace);
	Bind(":id", &user_id);
	Bind(":sid", &survey_id);
	Bind(":qid", &question_id);
	Bind(":lresponse", &responseLength);
	BindLongRaw(":response", (unsigned char *)pResponse, responseLength);

	// Let's try it...
	// Call oexn directly
	rc	= oexec((cda_def *)mpCDACurrent);

	// If we got a rc == -9 then it's probably an integrity
	// violation, and we need to UPDATE a row, instead of 
	// adding it.
	if (rc == -9)
	{
		// Close the cursor
		Close(&mpCDAOneShot);
		SetStatement(NULL);

		// Open a new one
		OpenAndParse(&mpCDAOneShot,
				 SQL_UpdateTextSurveyResponse);

		// Binds
		Bind(":marketplace", &marketplace);
		Bind(":id", &user_id);
		Bind(":sid", &survey_id);
		Bind(":qid", &question_id);
		Bind(":lresponse", &responseLength);
		BindLongRaw(":response", (unsigned char *)pResponse, responseLength);
		
		// Do it
		Execute();
	}

	// This Check works for both the insert and update
	// case (though it's redundant in the latter);
	Check(rc);

	// Make the commitment
	Commit();

	// Close the cursor
	Close(&mpCDAOneShot);
	SetStatement(NULL);


	return;
}

